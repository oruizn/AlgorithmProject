#### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

难度：中等

给定一个整数 *n*，求以 1 ... *n* 为节点组成的二叉搜索树有多少种？

**示例:**

```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```



C++：迭代算法(动态规划)

```
思路：
	节点1：如果只有1个节点，必为根节点，无左右子树。G(1) = G(0)*G(0)，左右子树节点个数都为0，G(0)=1；
	节点2：如果有2个节点，除了有一个根节点，另外一个节点可以放在左右子树上，左子树有，右子树就没有；右子树有，那左子树就没有。G(2)=G(0)*G(1)+G(1)*G(0);
	节点3：如果有3个节点，除了有一个根节点，另外两个节点可以放在左右子树上，左子树有2个，则右子树没有，左子树形态与步骤2的相同；左右子树均1个，则形态与步骤1的相同；右子树有两个，则左子树没有，右子树形态与步骤2相同。因此，G(3)=G(0)*G(2)+G(1)*G(1)+G(2)*G(0);
	...
	节点n：G(n)=G(0)*G(n-1)+G(1)*G(n-2)+...+G(n-2)*G(1)+G(n-1)*G(0)
	
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1);//创建一个数组记录G(n)
        dp[0] = 1;//G(0)=1
        for(int i = 1; i <= n; i++){  //n最小值为1
            for(int j = 0; j < i; j++){  //迭代上面的公式，j最小为0。一开始左子树为0个节点，右子树则有n-0-1个节点，1为根节点，需要排除掉
                dp[i] += dp[j] * dp[i - j -1];
            }
        }
        return dp[n];
    }
};

```





